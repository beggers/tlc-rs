// ===================
// Silent parsed rules
// ===================
//
// These are rules which need to be parsed for file correctness and understanding
// but don't need to be tokenized or otherwise used in the AST.
//
// Wherever there is possible collision with rust keywords, the prefix tla_
// is used (e.g. modules).

// https://docs.rs/pest/latest/pest/#whitespace-and-comment
// Things get weird when we add NEWLINE here -- pest thinks multiple newlines
// are allowed in module declarations which breaks the
// multiple_nested_modules test. Keep NEWLINE explicit.
WHITESPACE = _{ " " | "\t" }

single_line = _{ "----" ~ "-"* }
double_line = _{ "====" ~ "="* }

def_eq = _{ "==" | "≜" }
set_in = _{ "\\in" | "∈" }
gets = _{ "<-" | "⟵" | "←" }
forall = _{ "\\A" | "\\forall" | "∀" }
exists = _{ "\\E" | "\\exists" | "∃" }
temporal_forall = _{ "\\AA" }
temporal_exists = _{ "\\EE" }
all_map_to = _{ "|->" | "⟼" | "↦" }
maps_to = _{ "->" | "⟶" | "→" }
langle_bracket = _{ "<<" | "〈" | "⟨" }
rangle_bracket = _{ ">>" | "〉" | "⟩" }
rangle_bracket_sub = _{ ">>_" | "〉_" | "⟩_" }
case_box = _{ "[]" | "□" }
case_arrow = _{ "->" | "⟶" | "→" }
colon = _{ ":" }
address = _{ "@" }
label_as = _{ "::" | "∷" }
placeholder = { "_" }
bullet_conj = _{ "/\\" | "∧" }
bullet_disj = _{ "\\/" | "∨" }

constant_list_decl = _{ "CONSTANTS" | "CONSTANT" }
extends_decl = _{ "EXTENDS" }
tla_mod_decl = _{ "MODULE" }
variable_list_decl = _{ "VARIABLES" | "VARIABLE" }

// ===================
// Base values
// ===================

ident = @{ ASCII_DIGIT* ~ ASCII_ALPHA+ ~ (ASCII_ALPHA | ASCII_DIGIT)* }

literal_value = { number_lit | string_lit | number_set_lit | string_set_lit }

nat_lit = @{ ASCII_DIGIT+ }
binary_lit = @{ ^"\\b" ~ ( "0" | "1" )+ }
octal_lit = @{ ^"\\o" ~ ( '0'..'7' )+ }
hex_lit = @{ ^"\\h" ~ ( ASCII_DIGIT | 'a'..'f' | 'A'..'F' )+ }
real_lit = @{ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+ }
number_lit = { real_lit | nat_lit | binary_lit | octal_lit | hex_lit }

nat_numbers_lit = { "Nat" }
int_numbers_lit = { "Int" }
real_numbers_lit = { "Real" }
number_set_lit = { nat_numbers_lit | int_numbers_lit | real_numbers_lit }

string_set_lit = { "STRING" }

string_lit = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// ===================
// Structured literals
// ===================

seq_lit = { langle_bracket ~ expr ~ ("," ~ expr)* ~ rangle_bracket }

// ===================
// Expressions
// ===================

expr = {
  (
    literal_value
    | if_then_else
    | seq_lit
    | "(" ~ expr ~ ")"
    | ident
  ) ~ NEWLINE*
}

if_then_else = {
  "IF" ~ NEWLINE* ~ expr ~ NEWLINE*
  ~ "THEN" ~ NEWLINE* ~ expr ~ NEWLINE*
  ~ "ELSE" ~ NEWLINE* ~ expr ~ NEWLINE*
}

op_defn = {
  ident ~ def_eq ~ expr ~ NEWLINE*
}

// ===================
// Files and Modules
// ===================

source_file = { NEWLINE* ~ tla_mod+ ~ NEWLINE* }

tla_mod = {
  single_line ~ tla_mod_decl ~ ident ~ single_line ~ NEWLINE*
  ~ (
      constant_list
      | extends_list
      | variable_list
      | op_defn
      | tla_mod
    )* ~ NEWLINE*
  ~ double_line ~ NEWLINE*
}

constant_list = {
  constant_list_decl ~ ident ~ ("," ~ ident ~ NEWLINE*)* ~ NEWLINE*
}

extends_list = {
  extends_decl ~ ident ~ ("," ~ ident)* ~ NEWLINE*
}

variable_list = {
  variable_list_decl ~ ident ~ ("," ~ ident ~ NEWLINE*)* ~ NEWLINE*
}